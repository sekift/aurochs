# aurochs简介
1、aurochs原意是欧洲野牛、原牛，于1627年灭绝。<br />
2、在这里aurochs是一个自动划分集群、管理集群的服务，拥有高性能、高可用、高扩展的特性。<br />

## 更新
2019-12-10<br />
1.完成redis-sentinel分组分布式逻辑。<br />

2019-11-28<br />
1.完成redis纯分布式逻辑。<br />

2018-05-28 初版 <br />
1.完成划分算法，完成集群自动划分。<br />

## 特性
1、自动将不同区域的机器划分成高可用集群；<br />
2、集群之间实现合并/分拆集群，实现小集群升级为大集群；<br />
3、集群后端储存使用Redis/Mysql，支持保存持久化（需要转移数据）、非持久化（缓存）内容。采用CS模式，可添加其他支撑；<br />
4、集群内部采用一致性Hash分组分节点，节点间实现failover(主从结构/主主结构)；<br />
5、解决热点内容、动态扩展、高性能高可用等问题；<br />

## 项目划分
按照不同的功能，分为五个项目；<br />
aurochs：父项目<br />
- aurochs-common：公共类<br />
1、提供基本功能，例如加载文件、算法等；<br />
- aurochs-server：配置端<br />
1、负责划分集群，分配、管理集群；<br />
- aurochs-redis：redis服务端<br />
1、从server获取集群配置，按一致性算法分组，组内实现failover；<br />
2、与redis连接，操作数据。<br />
Redis使用4.0版本，同时也能用Redis2.6（代码有少量改动）。<br />
- aurochs-redis-sentinel：redis哨兵服务端<br />
1、从server获取集群配置，按一致性算法分组，每一组都是一个sentinel集群，一主二从配置；<br />
2、与redis连接，操作数据。<br />
Redis使用3.x版本，暂未升级到4.x或5.x，升级估计代码需少量改动即可。
- aurochs-mysql：mysql服务端<br />
1、从server获取集群，处理转移；<br />
2、与mysql连接，操作数据。<br />

## 设计理念
### 1.名称
1.1）机器（machine）：单台计算机，可以是物理机或虚拟机；<br />
1.2）区域(zone)：区域，例如交换机、地区；<br />
1.3）集群（cluster）：由众多机器共同承载业务组成的有关联的群体；<br />
1.4）组（group）：集群之中机器可互相切换数据的小群体；<br />
1.5）节点（point）：有固定位置的机器。<br />
### 2.怎么组织高可用集群？
简单来说要构造一个高可用集群，会对集群里的机器排布有些要求：集群内（组内）的机器尽可能是从不同区域中选取的，这样之间的failover不会因为一个区域的机器连接不上而不能提供服务，从而实现高可用。下面简单介绍思路。<br />
2.1）先举个例子：现有北京、广州两地各两台机器：b1,b2;g1,g2，需要分成两个集群。同一个地区的机器是平等关系，那么有两种方案:<br />
solve1={cluster1=[b1,b2],cluster2=[g1,g2]} <br />
solve2={cluster1=[b1,g1],cluster2=[b2,g2]} <br />
现在假设北京停电了，那么b1,b2机器都不可用，这时solve1的cluster1集群彻底不可用；而solve2中的b1的请求会转移到g1上，b2的请求会转移到g2上，两个集群都可用。此时可以说solve2优于solve1.<br />
2.2）在举个例子：现有北京、广州、上海三地各四台机器：b1,b2,b3,b4;g1,g2,g3,g4;s1,s2,s3,s4，需分成3个集群。那么机器之间的排布会有很多种方案，下面挑出其中3种：<br />
solve1={cluster1=[b1,b2,b3,b4],cluster2=[g1,g2,g3,g4],cluster3=[s1,s2,s3,s4]} <br />
solve2={cluster1=[b1,s4,s3,s2],cluster2=[s1,g4,g3,g2],cluster3=[g1,b4,b3,b2]} <br />
solve3={cluster1=[b1,g2,s3,b4],cluster2=[s1,b2,g3,s4],cluster3=[g1,s2,b3,g4]} <br />
为了分散压力，选择两个节点作为一组，组内可以failover，组之间不可以。因此，解决方案如下：<br />
solve1={cluster1=[b1,b2;b3,b4],cluster2=[g1,g2;g3,g4],cluster3=[s1,s2;s3,s4]} <br />
solve2={cluster1=[b1,s4;s3,s2],cluster2=[s1,g4;g3,g2],cluster3=[g1,b4;b3,b2]} <br />
solve3={cluster1=[b1,g2;s3,b4],cluster2=[s1,b2;g3,s4],cluster3=[g1,s2;b3,g4]} <br />
现在假设北京停电了，那么b$1-4机器都不可用，此时solve1的cluster已彻底不可用；solve2的cluster3第二组b3,b2同时不可用，而且不能failover；而solve3的b1会转到g2，b4转到s3，b2转到s1，b3转到g4，从而整体可用。<br />
2.3）经过前面的两个例子，可以看出，组之内以及组之间的机器尽量不同同一个区域（就是最混淆的状态）会构造出最优的集群。<br />
### 3.圆内反射算法
经过前面的分析，我们了解了怎么样的集群是最优的，当机器数量少时可以人工分配最优集群，但是当数量多时，人工就显得不方便了.例如有8个区域共400台机器，需要分别取100、50、50、20、20、20、20、20、10、10、10、10、10、10、10、10、10、10台机器组集群，共18个集群。此时需要自动分配、组织集群。<br />
3.1）先作些规定，因为需两台一组，那么机器总数和集群总数都需是偶数；<br />
3.2）再说明一个数学式，取一个与总数n互素的数i（称为步长），那么从小于n的任何一个数k开始，以i递增并取n的余数，会在n次后取光1到n的数。举个例子，总数n=10，取步长i=3，从k=1开始，那么取数分别是：1%10=1，4%10=4，7%10=7，10%10=0（此时取最大值10），13%10=3，16%10=6，19%10=9，22%10=2，25%10=5，28%10=8。这个算法也可以称为圆内反射算法，因为将n个点以相同的距离在一个圆上分布，那么从任何一点k出发，以夸过i个距离的角度指到i+k的点上，然后重复这个步骤，直到取尽n个数，最终的队列与前面的是一样的。同时可以证明，随着k和i的不同，最终生成的队列也是不同的。<br />
### 4.圆内反射算法与集群构造
那么圆内反射算法是怎么样与集群构造联系在一起的呢？<br />
4.1）回顾2.1中的例子，现有北京、广州两地各两台机器：b1,b2;g1,g2，需要分成两个集群，机器总数为4，那么可以取3（与4互素）为步长，从1开始 ，那么选取的队列是b1、g2、g1、b2，构成集群{b1,g2}和{g1,b2}。<br />
4.2）回顾2.2种的例子，现有北京、广州、上海三地各四台机器：b1,b2,b3,b4;g1,g2,g3,g4;s1,s2,s3,s4，需分成3个集群。总数为12，而小于12中有5、7、11与12互素，那么都可选作为步长，而都从1开始，那么它们所构成的队列（已合为集群）分别为：<br />
5={cluster1=[b1,g2;s3,b4],cluster2=[s1,b2;g3,s4],cluster3=[g1,s2;b3,g4]}<br />
7={cluster1=[b1,g4;b3,s2],cluster2=[g1,s4;g3,b2],cluster3=[s1,b4;s3,g2]}<br />
11={cluster1=[b1,s4;s3,s2],cluster2=[s1,g4;g3,g2],cluster3=[g1,b4;b3,b2]}}<br />
当然，1也与12互素，但是如果是这样，构成的集群就是2.2中的solve1，可用性是最差的，所以一般不取。<br />
现在，构造成了3个集群，按照之前的原则，可以看出5和7的solve都是可取的，但怎么自动选择呢？特别是在集群复杂时。<br />
### 5.如何自动评价集群？
按照前面的思路，最混淆的状态会是最优集群，那么可以定义下面两条评分规则：<br />
5.1）对比组内：集群组内节点在同一区域评分为0，不同评8分。例如[b1,s4;s3,s2]，会评8分，因为b1和s4不在同一个区域评8分，而s3和s2在评0分，总分为8分。<br />
5.2）对比组外：集群之间的组按不同区域的不同评1/2/3/4分。例如[s1,s4;s3,s2]机器都在同一个区域，评1分；[b1,s4;s3,s2]以及[b1,s4;b3,s2]机器在两个区域，评2分；[b1,s4;b3,g2]评3分，[b1,s1;g1,h1]评4分。如果集群构成如[b1,s1;g1,h1;b2,s2]，那么会每两组地进行对比，最后将评分相加。<br />
5.3）现在看看4.2中的集群分别的得分情况：<br />
5={cluster1=[b1,g2;s3,b4],cluster2=[s1,b2;g3,s4],cluster3=[g1,s2;b3,g4]}，cluster1得8+8+3分，cluster2得8+8+3分，cluster3得8+8+3分，共得57分。<br />
7={cluster1=[b1,g4;b3,s2],cluster2=[g1,s4;g3,b2],cluster3=[s1,b4;s3,g2]}，cluster1得8+8+3分，cluster2得8+8+3分，cluster3得8+8+3分，共得57分。<br />
11={cluster1=[b1,s4;s3,s2],cluster2=[s1,g4;g3,g2],cluster3=[g1,b4;b3,b2]}}，cluster1得8+0+2分，cluster2得8+0+2分，cluster3得8+0+2分，共得30分。<br />
那么结果很明显，取得分最大的分配，就是步长是5或7。<br />
### 6.如何选择最优的集群分配？
经过5的评价得分，最终选出了步长为5或7时是最优集群，现在需要确定使用哪个分配。显然机器的地位是平等的，那么作一个硬性规定：<br />
选分值最大而且步长最小的分配。<br />
很明显上面的5和7的得分都是57，但5小于7，因此选定步长5的集群分配作为最终结果，以致在使用后数据不会错乱：<br />
5={cluster1=[b1,g2;s3,b4],cluster2=[s1,b2;g3,s4],cluster3=[g1,s2;b3,g4]}<br />
### 7.再举个例子
现在有北京、广州、上海、杭州四地共32台机器：b1,b2,b3,b4,b5,b6,b7,b8;g1,g2,g3,g4,g5,g6,g7,g8;s1,s2,s3,s4,s5,s6,s7,s8;h1,h2,h3,h4,h5,h6,h7,h8，需要分别按12、8、8、4台机器一个集群划分，那么结过自动划分，最终的结果是：<br />
9={cluster1=[b1,g2;s3,h4;b5,g6;s7,h8;g1,s2;h3,b4],cluster2=[g5,s6;h7,b8;s1,h2;b3,g4],cluster3=[s5,h6;b7,g8;h1,b2;g3,s4],cluster4=[h5,b6;g7,s8]}<br />
### 8.为什么要小集群升级为大集群？
小集群在一定的时间内会满足，但是一旦需求增大则承受不住，需要添加机器。为什么不在集群增加机器？第一原机器用了几年老化了，如果加新机器配置不同；第二，增加后旧机器发生故障更是个问题；第三，增加机器和升级集群都会有振荡，只是振荡率不同，为了统一，干脆升级到大集群。<br />

## 未来
- 1.机器配置后期考虑使用Zookeeper做高可用； <br/>
- 2.同样地，MQ、Web、RPC等应用也能以相同的方式接入，但具体实现有所不同。<br/>

## 问题
- 暂时未发现问题。<br />
